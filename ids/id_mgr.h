// Keeps track of IDs. IDs generated by the same "struct IdMgr"
// are guaranteed to be different from one another (although
// destroyed IDs might be reused). IDs generated by different
// managers are assumed to have purposes different enough to
// never be compared, so they might share the same values. All
// IDs generated by a manager is guaranteed to have a value
// between 0 and the greatest number of IDs that have ever
// belonged to that manager, inclusive. No generated IDs have
// the value of the "PCECS_INVALID_ID" macro.

#ifndef ID_MGR_H
#define ID_MGR_H

#include <stdlib.h>
#include <stdbool.h>
#include "id.h"
#include "id_pool.h"

// A manager that creates unique IDs, destroys them and
// keeps track of whether they exist or not.
struct IdMgr
{
        pcecs_id_t max_id;
        struct IdPool unused_ids;
};

// Create a "struct IdMgr" with no IDs.
struct IdMgr create_id_manager(void);

// Destroy a "struct IdMgr". Nothing happens to IDs
// generated by it.
void destroy_id_manager(struct IdMgr * mgr);

// The number of IDs generated by "mgr" that are not
// yet destroyed.
pcecs_id_t ids_in_use_count(const struct IdMgr * mgr);

// Returns "true" if "id" is a created-and-not-yet-
// destroyed ID generated by "mgr", "false" if not.
bool id_in_use(const struct IdMgr * mgr, pcecs_id_t id);

// Generates a new ID that does not share its value
// with any other IDs used by "mgr". It might, however,
// share its value with IDs used by other id managers
// or IDs previously destroyed by "mgr".
pcecs_id_t generate_id(struct IdMgr * mgr);

// Marks an ID as unused by "mgr". "generate_id"
// using the same id manager might regenerate the
// destroyed ID. Assumes "id" is used by "mgr".
void destroy_id(struct IdMgr * mgr, pcecs_id_t id);

#endif
